## Auth

It outlines different approaches of authenticating applications and their features.

- [JWT](#jwt)
- [Session(Cookie)](#session)
- [SSO](#sso)
- [OAuth2](#oauth2)
- [SAML](#saml)
- [SAML vs OAuth](#saml-vs-oauth)
- [More Readings](#more-readings)

### JWT

- comprised of 3 parts - **xxxx.yyyyy.zzzz** = **header**.**payload(claim)**.**signature**. Each bit is base64 encoded.

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
          header                                         payload/claim                                                       signature
```

- header is as follow. It shows the algorithm we use to generate the signature. It needs to be base64 encoded.

```js
{
  "typ": "JWT",
  "alg": "HS256"
}
```

- payload(claim) contains metadata as follow. It then base64 encoded.

```js
{
  "iss": "Mr He. JWT", // issuer
  "iat": 1441593502, // issued at
  "exp": 1441594722, // expire at
  "aud": "www.lendi.com.au", // audience - server
  "sub": "david.he@lendi.com" // subject - client
}
```

- signature is generated by joining the above two base64 encoded strings first and then encrypted with secret - 'I love this game'.

```js
signature = header_alg(xxxxxxx.yyyyyyyy, YOUR_SECRET);
```

#### Important

- Never ever put the senstive data in **header** and **payload** - they are `base64` encoded not encrypted!!!
- Why do we need signature? - It prevents somebody modifying the data.
- How does server do the authentication? - Server will use the specified algorithm in the header, secret stored on the server, **header** and **payload** to generate another signature. Then, server will do the comparison with the sent one if they don't match it indicates the token has been tampered with.
- With JWT, you should NEVER EVER store token in db on server side. Instead it needs to be stored safely on client side.
- It makes scaling easier since any server in a cluster can serve the request given no session is kept on the server side.
- People use JWT to protect their APIs.
![jwt-based-auth](./jwt-based-auth.png)

#### Downsides

- JWT can be a sizeable piece of data in the header!
- Not suitable for holding user sessions i.e shopping cart

#### FAQs

- #### How to invalidate a token?

A: Add a property to your user object in the server database, to reference the datetime the token was created at. To invalidate the token, just update its value, and if `iat` (holding the same value at the time of token creation) is older than updated value, you can reject the token.

- #### Where should I save it on the client side?

A: JWT needs to be stored inside an `httpOnly cookie` - a special kind of cookie that’s only sent in HTTP requests to the server, and it’s never accessible (both for reading or writing) from JavaScript running in the browser.

Never save it to `localStorage`. If any of the third-party scripts you include in your page gets compromised, it can access all your users’ tokens.

---

### Session

- Used to know user session state.
- stateful - both server and client needs to keep a copy.
- sessionId is created and stored on the server (db or cache). It's also being sent down the wire to client through cookie.
- session data itself can be saved into db table.
- After authenticated, all subsequent requests will have sessionId attached automatically by browser.

![session-based-auth](./session-based-auth.png)

#### typical auth process

1. User enters their login credentials.
2. Server verifies the credentials are correct and creates a session which is then stored in a database.
3. A cookie with the session ID is placed in the users browser.
4. On subsequent requests, the session ID is verified against the database and if valid the request processed.
5. Once a user logs out of the app, the session is destroyed both client-side and server-side.

#### Downsides

- Cookies normally work on a single domain or subdomains and they are normally disabled by browser if they work cross-domain (3rd party cookies)
- Given the fact it's stored in server's memory, scaling becomes a problem since a different server than the original one who generates the sessionId would fail to know incoming request state.

#### FAQs

- #### How to manage session in a distributed environment?

A: Couple of ways:

- Sticky session - Which ensures that all requests from a specific user will be sent to the same server who handled the first request corresponding to that user, thus ensuring that session data is always correct for a certain user. The problem is it will cause uneven load distribution across servers.

- Centralized session storage - Means that when a user accesses a microservice, user data can be obtained from shared session storage, ensuring that all microservices can read the same session data

Other approaches are discussed in the `Microservices Authentication and Authorization Solutions` below.

- #### Where should I store session data?

A: 2 possible ways:

- Memory session store is going to be reset on every app re-lauch. Also it's fastest. i.e Redis
- Database session store, is going to be safe with app re-lauch. And at some point you will have alot of session objects which you might want to clean up. And same session stored in database can be even accessed from different apps.

---

### SSO

![](./sso_auth0.png)

Read more about [what is SSO and how it works](https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/)

---

### OAuth2

- Four participants
  - Resource Owner - User
  - Resource Server - Google i.e Google Calendar
  - Authorization Server - Authenticate user credentials and gain user **access_token**
  - Client - 3rd party app i.e lendi
- **Resource Server** and **Authorization Server** can be the same server
- Full workflow
  1. **Client** sends request to **Resource Owner** for authorization. The OAuth **Client** includes its identifier, requested scope, local state, and a redirection URI.
  2. **Resource Owner** grants the access and sends the authorization code back to **Client**
  3. **Client** passes the authorization code to **Authorization Server**
  4. **Authorization Server** authenticates the code and sends **access_token** back to **Client**
  5. **Client** can then use **access_token** to get access to resources on the **Resource Server**
- In offline mode, **Authorization Server** also sends a **refresh_token** which is used later to exchange for another fresh **access_token** after previous one is expired without needing to go through all the steps again.

![](./oauth_2.png)

### SAML

Saml is a protocol for authentication. i.e Authenticating a client through IdP that's compatible with SAML so the client can access your application which it does not provide authentication but rather actual services/functionalities.

![saml](saml.png)

### SAML vs OAuth

They are two different security protocols often used to implement SSO. The major difference is OAuth is primarily used for authorization whilst SAML is for authentication.

References

- [OAuth-vs-SAML](https://www.cloudflare.com/learning/access-management/what-is-oauth/)
- [SAML-vs-OAuth-vs-OPENID](https://juejin.im/post/6844903634094784520)
- [Use JumpCloud as IDP to authenticate users to access AWS](https://www.youtube.com/watch?v=JlX4pyQBecM)
- [Identity Providers and Federation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers.html)

---

### More readings

[Microservices Authentication and Authorization Solutions](https://medium.com/tech-tajawal/microservice-authentication-and-authorization-solutions-e0e5e74b248a)
