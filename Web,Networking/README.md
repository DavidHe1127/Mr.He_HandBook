# Web, Networking

* [HTTP, SSL/TLS](./http(s).md)
* [Perf Tips](./perf.md)
* [Web Caching](./web_caching.md)
* [SSH](./ssh.md)

## Miscellaneous

* [Premature Optimization](#premature_optimization)
* [WebAssembly](#web-assembly)
* [JWT](#jwt)
* [SSO](#sso)
* [CORS](#cors)
* [OAuth2](#oauth2)

### premature_optimization
Any coding practice that makes your code harder to understand in the name of performance is a `premature optimization`.

***

### Web Assembly

* It's a new kind of code that can be compiled (ahead of time) down into a binary format that browsers can read. This means that high-level languages (C, C++) can be compiled down into a format that is legible to the browser. For developers that want to do some heavy computing on the web, this is a huge plus.
* At the time of writing, it does not support `DOM access` - so JS is still needed.

***

### JWT

#### Basics

* JWT is comprised of 3 parts - **xxxx.yyyyy.zzzz** = **header**.**payload(claim)**.**signature**
* header is as follow. It shows the algorithm we use to generate the signature. It needs to be base64 encoded.
```js
{
  "typ": "JWT",
  "alg": "HS256"
}
```
* payload(claim) contains metadata as follow. It then base64 encoded.
```js
{
  "iss": "Mr He. JWT", // issuer
  "iat": 1441593502, // issued at
  "exp": 1441594722, // expire at
  "aud": "www.lendi.com.au", // audience - server
  "sub": "david.he@lendi.com" // subject - client
}
```
* signature is generated by joining the above two base64 encoded strings first and then encrypted with secret - 'I love this game'.
```js
signature = header_alg(xxxxxxx.yyyyyyyy, YOUR_SECRET)
```

#### Key Notes

* Never ever put the senstive data in **header** and **payload** - they are encoded not encrypted!!!
* Why do we need signature? - It prevents somebody modifying the data.
* How does server do the authentication? - Server will use the specified algorithm in the header, secret stored on the server, **header** and **payload** to generate another signature. Then, server will do the comparison with the sent one if they don't match it indicates the token has been tampered with.

***

### SSO

* [What is SSO and how it works](https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/)
* [keypoints](#keypoints)

***

### CORS

* [What is it?](#what-is-it)
* [Why do we need it?](#why-do-we-need-it)
* [JSONP](#jsonp)
* [How to enable it?](#how-to-enable-it)
* [Preflight](#preflight)

#### What is it
Stands for cross-origin resource sharing. i.e ajax calls can only access resources on your domain not some other domains.

Note, client's request still hits the server and gets the response, but HTTP client like `fetch` which follows `same origin policy` will prevent the client accessing the response since there is a lack of `Access-Control-Allow-Origin` header. You can set up a proxy server to fix the problem if you don't have control over the server.

[Useful link](https://stackoverflow.com/questions/43871637/no-access-control-allow-origin-header-is-present-on-the-requested-resource-whe/43881141#43881141)

#### Why do we need it
Security reasons. Protect your websites from CSRF or XSRF. The way CSRF works is as follow:
  * User David signs in to a reliable website A
  * Authentication is passed. A sets **cookie** on response header to retain David's login
  * User David goes to malicious website B without firstly signing out from website A
  * website B then takes **cookie** to forge a request to website A saying `buy pizza 100000+ pieces`
CSRF can be prevented by **same-origin policy**

#### jsonp
Altough ajax requests are restricted, remote scripts loaded via `src tags` are free to go.
```js
<script>
  function logMessage(json) {
    console.log(json.message);
  }
</script>
<script src="http://example.com/jsonpMessage?cb=logMessage"></script>
```
Downside of jsonp is - it only works for http `GET`.

#### How to enable it
**Origin** header specifies where this request is being sent from.
```js
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```
Server will respond without **Access-Control-Allow-Origin** which will in turn trigger `onerror` in the ajax call.

Turn on cors for whole list of webistes as exceptions to same-origin policy. This time, server will respond
```js
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```
Now, ajax calls to another domain is allowed.

#### preflight
For non-simple requests - `PUT`, `DELETE` or `content-type: application/json` header, an `OPTIONS` http request will be sent first asking if the requested site is within the exception list and available http methods and headers. If answer is 200, the actual request will then be issued.

To avoid sending too many `OPTIONS`, One approach is - frontend sends ajax to its server (only serves up frontend code) which then forwards the requests to api server - backend. Because the communication is between two servers, preflight calls are completed avoided.

***

### OAuth2

* Four participants
  * Resource Owner - User
  * Resource Server - Google i.e Google Calendar
  * Authorization Server - Authenticate user credentials and gain user **access_token**
  * Client - 3rd party app i.e lendi
* **Resource Server** and **Authorization Server** can be the same server
* Full workflow
  1. **Client** sends request to **Resource Owner** for authorization. The OAuth **Client** includes its identifier, requested scope, local state, and a redirection URI.
  2. **Resource Owner** grants the access and sends the authorization code back to **Client**
  3. **Client** passes the authorization code to **Authorization Server**
  4. **Authorization Server** authenticates the code and sends **access_token** back to **Client**
  5. **Client** can then use **access_token** to get access to resources on the **Resource Server**
* In offline mode, **Authorization Server** also sends a **refresh_token** which is used later to exchange for another fresh **access_token** after previous one is expired without needing to go through all the steps again.

![](./oauth_2.png)
