## Jenkins

- [Env Var](#env-var)
- [Workspace](#workspace)
- [Reference func in file](#reference-func-in-file)
- [Conditional build](#conditional-build)
- [Retrieve branch name](#retrieve-branch-name)
- [Best practices](#best-practices)
- Read more
  - [Jenkins CheatSheet — Know The Top Best Practices of Jenkins](https://medium.com/edureka/jenkins-cheat-sheet-e0f7e25558a3)
- Tips
  - [Skip whole build](#skip-whole-build)

### Env Var

- `withEnv(["env=value]) {}` block can overwrite any env vars.
- Vars set using `environment {}` block **CANNOT** be assigned with another value using imperative `env.VAR = "value"` assignment.
- Imperative `env.VAR = "value"` assignment can overwrite only env vars created using imperative assignment.

```groovy
script {
  withEnv(["FOO=foobar"]) { // it can overwrite any env variable
      echo "FOO = ${env.FOO}" // prints "FOO = foobar"
  }
}
```

### Workspace

The workspace directory is where Jenkins builds your project: it contains the source code Jenkins checks out, plus any files generated by the build itself. This workspace is reused for each successive build—there is only ever one workspace directory per project, and the disk space it requires tends to be relatively stable.

### Reference func in file

Example.Groovy
```groovy
def exampleMethod() {
    //do something
}

def otherExampleMethod() {
    //do something else
}
return this
```

JenkinsFile

```groovy
node {
    def rootDir = pwd()
    def example = load "${rootDir}@script/Example.Groovy "
    example.exampleMethod()
    example.otherExampleMethod()
}
```

### Conditional build
Any condition inside `when` needs to be evaluated `true` for `stage` block to run. Note `env.BRANCH_NAME` or `branch 'master'` will only work in `multi-branch` pipeline env.

```groovy
stage('Deputy - build completed') {
    when {
        expression {
            ifDoDeputy()
        }
    }
    steps {
        sh './batect deputy-complete-build'
    }
}
...
def ifDoDeputy() {
    def isDeputyEnabled = env.DEPUTY_ENABLED == 'true'
    def isRightBranch = env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'develop'
    return isDeputyEnabled && isRightBranch
}

# OR

when {
  anyOf { branch 'master'; branch 'develop' }
  expression {
    env.DEPUTY_ENABLED == 'true'
  }
}
```

### Retrieve branch name

Access your feature branch name through `BRANCH_NAME` var. However, it returns `PR-*` as soon as a branch has a PR made from it. Use `CHANGE_BRANCH` instead to get feature branch name if you still want it.

```groovy
stage('Set Build Name') {
  steps {
    script {
      if (env.BRANCH_NAME.startsWith('PR')) {
        currentBuild.displayName = "#${env.BUILD_NUMBER} - ${env.CHANGE_BRANCH}"
      } else {
        currentBuild.displayName = "#${env.BUILD_NUMBER} - ${env.BRANCH_NAME}"
      }
    }
  }
}
```



### Best practices

#### Combine multiple steps into one

```groovy
// do this
sh """
  echo Installing foundational dependency...
  ./batect install-foundational-dependency
  echo Bootstraping
  ./batect bootstrap
"""

// not this as it will require connections and resources on the agent and master to be created and cleaned up
// echo "Installing foundational dependency..."
// sh "./batect install-foundational-dependency"
// echo "Bootstraping"
// sh "./batect bootstrap"
```

---

## Tips

### Skip whole build

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            when {
                return SKIP_CI == 'true'
            }
            stages {
                stage('install dependencies') {
                    steps {
                        //..
                    }
                }
                stage('test') {
                    steps {
                        //...
                    }
                }
            }
        }
    }
}
```



