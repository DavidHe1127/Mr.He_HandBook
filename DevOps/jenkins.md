## Jenkins

- [Env Var](#env-var)
- [Workspace](#workspace)
- [Reference func in file](#reference-func-in-file)
- [Conditional build](#conditional-build)
- [Best practices](#best-practices)
- Read more
  - [Jenkins CheatSheet — Know The Top Best Practices of Jenkins](https://medium.com/edureka/jenkins-cheat-sheet-e0f7e25558a3)
- Tips
  - [Dynamic branch build](#dynamic-branch-build)

### Env Var

- `withEnv(["env=value]) {}` block can overwrite any env vars.
- Vars set using `environment {}` block **CANNOT** be assigned with another value using imperative `env.VAR = "value"` assignment.
- Imperative `env.VAR = "value"` assignment can overwrite only env vars created using imperative assignment.

```groovy
script {
  withEnv(["FOO=foobar"]) { // it can overwrite any env variable
      echo "FOO = ${env.FOO}" // prints "FOO = foobar"
  }
}
```

### Workspace

The workspace directory is where Jenkins builds your project: it contains the source code Jenkins checks out, plus any files generated by the build itself. This workspace is reused for each successive build—there is only ever one workspace directory per project, and the disk space it requires tends to be relatively stable.

### Reference func in file

Example.Groovy
```groovy
def exampleMethod() {
    //do something
}

def otherExampleMethod() {
    //do something else
}
return this
```

JenkinsFile

```groovy
node {
    def rootDir = pwd()
    def example = load "${rootDir}@script/Example.Groovy "
    example.exampleMethod()
    example.otherExampleMethod()
}
```

### Conditional build
Any condition inside `when` needs to be evaluated `true` for `stage` block to run. Note `env.BRANCH_NAME` or `branch 'master'` will only work in `multi-branch` pipeline env.
```
stage('Deputy - build completed') {
    when {
        expression {
            ifDoDeputy()
        }
    }
    steps {
        sh './batect deputy-complete-build'
    }
}
...
def ifDoDeputy() {
    def isDeputyEnabled = env.DEPUTY_ENABLED == 'true'
    def isRightBranch = env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'develop'
    return isDeputyEnabled && isRightBranch
}

# OR

when {
  anyOf { branch 'master'; branch 'develop' }
  expression {
    env.DEPUTY_ENABLED == 'true'
  }
}
```



### Best practices

#### Combine multiple steps into one

```groovy
// do this
sh """
  echo Installing foundational dependency...
  ./batect install-foundational-dependency
  echo Bootstraping
  ./batect bootstrap
"""

// not this as it will require connections and resources on the agent and master to be created and cleaned up
// echo "Installing foundational dependency..."
// sh "./batect install-foundational-dependency"
// echo "Bootstraping"
// sh "./batect bootstrap"
```

---

## Tips

### Dynamic Branch Build
It is possible to dynamically specify which branch to build. Below shows an example of this when using `Pipeline` as item type.

First, add a string build param with `BRANCH` as name and `master` as default.
Next, add another `branch specifier` valued `${BRANCH}`.

To confirm it works, select `build with param` and you should be prompted for branch name.





