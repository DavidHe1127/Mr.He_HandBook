## Auth

It outlines different approaches of authenticating applications and their features.

- [JWT](#jwt)
- [Session(Cookie)](#session)
- [GITHUB OIDC](./github-oidc.md)
- [SSO](#sso)
- [OAuth2](#oauth2)
- [SAML](#saml)
- [SAML vs OAuth](#saml-vs-oauth)
- [CORS](./cors.md)
- [DDos](#ddos)
- [Fingerprinting](#fingerprinting)
- [SSL Cert](#ssl-cert)
- [HSM](#hardware-security-module)

- [References](#references)

### JWT

- comprised of 3 parts - **xxxx.yyyyy.zzzz** = **header**.**payload(claim)**.**signature**. Each bit is base64 encoded.

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
          header                                         payload/claim                                                       signature
```

- header is as follow. It shows the algorithm we use to generate the signature. It needs to be base64 encoded.

```js
{
  "typ": "JWT",
  "alg": "HS256"
}
```

- payload(claim) contains metadata as follow. It then base64 encoded.

```js
{
  "iss": "Mr He. JWT", // issuer
  "iat": 1441593502, // issued at
  "exp": 1441594722, // expire at
  "aud": "www.lendi.com.au", // audience - server
  "sub": "david.he@lendi.com" // subject - client
}
```

- signature is generated by joining the above two base64 encoded strings first and then encrypted with secret - 'I love this game'.

```js
signature = header_alg(xxxxxxx.yyyyyyyy, YOUR_SECRET);
```

#### Important

- Never ever put the senstive data in **header** and **payload** - they are `base64` encoded not encrypted!!!
- Why do we need signature? - It prevents somebody modifying the data.
- How does server do the authentication? - Server will use the specified algorithm in the header, secret stored on the server, **header** and **payload** to generate another signature. Then, server will do the comparison with the sent one if they don't match it indicates the token has been tampered with.
- With JWT, you should NEVER EVER store token in db on server side. Instead it needs to be stored safely on client side.
- It makes scaling easier since any server in a cluster can serve the request given no session is kept on the server side.
- People use JWT to protect their APIs.
  ![jwt-based-auth](./jwt-based-auth.png)

#### Downsides

- JWT can be a sizeable piece of data in the header!
- Not suitable for holding user sessions i.e shopping cart

#### FAQs

- #### How to invalidate a token?

A: Add a property to your user object in the server database, to reference the datetime the token was created at. To invalidate the token, just update its value, and if `iat` (holding the same value at the time of token creation) is older than updated value, you can reject the token.

- #### Where should I save it on the client side?

A: JWT needs to be stored inside an `httpOnly cookie` - a special kind of cookie that’s only sent in HTTP requests to the server, and it’s never accessible (both for reading or writing) from JavaScript running in the browser.

Never save it to `localStorage`. If any of the third-party scripts you include in your page gets compromised, it can access all your users’ tokens.

---

### Session

- Used to know user session state.
- stateful - both server and client needs to keep a copy.
- sessionId is created and stored on the server (db or cache). It's also being sent down the wire to client through cookie.
- session data itself can be saved into db table.
- After authenticated, all subsequent requests will have sessionId attached automatically by browser.

![session-based-auth](./session-based-auth.png)

#### typical auth process

1. User enters their login credentials.
2. Server verifies the credentials are correct and creates a session which is then stored in a database.
3. A cookie with the session ID is placed in the users browser.
4. On subsequent requests, the session ID is verified against the database and if valid the request processed.
5. Once a user logs out of the app, the session is destroyed both client-side and server-side.

#### Downsides

- Cookies normally work on a single domain or subdomains and they are normally disabled by browser if they work cross-domain (3rd party cookies)
- Given the fact it's stored in server's memory, scaling becomes a problem since a different server than the original one who generates the sessionId would fail to know incoming request state.

#### FAQs

- #### How to manage session in a distributed environment?

A: Couple of ways:

- Sticky session - Which ensures that all requests from a specific user will be sent to the same server who handled the first request corresponding to that user, thus ensuring that session data is always correct for a certain user. The problem is it will cause uneven load distribution across servers.

- Centralized session storage - Means that when a user accesses a microservice, user data can be obtained from shared session storage, ensuring that all microservices can read the same session data

Other approaches are discussed in the `Microservices Authentication and Authorization Solutions` below.

- #### Where should I store session data?

A: 2 possible ways:

- Memory session store is going to be reset on every app re-lauch. Also it's fastest. i.e Redis
- Database session store, is going to be safe with app re-lauch. And at some point you will have alot of session objects which you might want to clean up. And same session stored in database can be even accessed from different apps.

---

### SSO

![](./sso_auth0.png)

Read more about [what is SSO and how it works](https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/)

---

### OAuth2

How GitHub App auth works

- A 网站跳转到 Github 的授权页面。
- Github 授权页面询问用户：“是否允许A网站获取下列权限”，用户点击“允许”，取得授权码。
- Github 授权页面重定向回 A 网站，同时在URL 上带上授权码。
- A 网站通过 URL 上的授权码往 Github 取回 Token (PAT)。
- A 网站使用这个 Token 去调用 Github API。

![](./oauth_2.png)

### SAML VS OAuth2.0

SAML - This protocol uses XML for data exchange and is built on top of the SOAP protocol. It has been widely used in enterprise federations for longer than OIDC. SAML messages are generally more verbose.
OIDC - Built on top of the OAuth 2.0 protocol, OIDC uses JSON for data exchange, which is more lightweight and web-friendly compared to XML. This makes OIDC better suited for modern web applications and mobile applications.

### DDos

A distributed denial-of-service (DDoS) attack requires an attacker to gain control of a network of online machines in order to carry out an attack. Computers and other machines (such as IoT devices) are infected with malware, turning each one into a bot (or zombie). The attacker then has remote control over the group of bots, which is called a botnet.

Once a botnet has been established, the attacker is able to direct the machines by sending updated instructions to each bot via a method of remote control. When the IP address of a victim is targeted by the botnet, each bot will respond by sending requests to the target, potentially causing the targeted server or network to overflow capacity, resulting in a denial-of-service to normal traffic. Because each bot is a legitimate Internet device, separating the attack traffic from normal traffic can be difficult.

### Fingerprinting

Collect as much data/infor as one could from the target so that one can know more details such as dentify network services, operating system number and version, software applications, databases, configurations and more.

This is often used by hacker so that they can come up with accurate hacking approaches to break target systems.

### SSL Cert

A conventional cert protects only one domain.

`subject` shows CN (common name) that is the DNS you wish to secure. This value needs to match request hostname i.e domain in your browser's address bar. If not, you will get `Common Name Mismatch` error.

The above check is aka Hostname Verification that involves a server identity check to ensure that the client is talking to the correct server and has not been redirected by a man in the middle attack.

The check involves looking at the certificate sent by the server, and verifying that domains in the `SAN/CN` (in the order of preference) field of the certificate matches the host portion of the URL used to make the request.

```
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
subject=/CN=fluentbit.ap-southeast-2.dev.parrodise.dev
issuer=/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
```

Use `openssl` to establish a TLS connection to the remote. This command will return more connection details which really helps with connection issues troubleshooting.

```shell
$ openssl s_client -connect some-domain.com.au:24223
```

#### SAN Cert

- SAN (Subject Alternate Name) - an optional property in the cert can be used to protect multiple hostnames by a single cert. i.e www.ssl.com/faq.ssl.com/ssl.com/tools.ssl.com can all be protected by one SAN cert.
- `CN` can only contain one entry: either a wildcard or non-wildcard name. It's not possible to specify a list of names covered by an SSL certificate `CN`. `SAN` was introduced to solve this limitation.
- SAN infor can be found in the cert by looking for `Extension: Subject Alternative Name` in chrome.
- In modern cert verification process, if `SAN` is found, always checks it first and ignores `CN`. One should put all protected domains in `SAN`.
- Only non-Wildcard names can be added to `SAN`.
- Consider using SAN if you want to protect multiple **domains** i.e `abc.com/bcd.com`. If multiple subdomains `www/faq/tools` under the same root domain `ssl.com`, consider using `SSL Wildcard Cert`.

To review SAN field of a cert - `openssl x509 -noout -ext subjectAltName -in cert.pem`.

References

- [Understand ssl cert](https://www.cnblogs.com/iiiiher/p/8085698.html)

### Hardware Security Module

- Used to store your cryptographic keys and perform cryptographic functions (signing a cert) without requester direct access to the key. Minimising the risk of private key exposures.
- It's like a vending machine. A vending machine stores drinks within an isolated internal environment. It’s designed to accept user inputs (i.e., your item selections) and generate outputs (i.e., pop out a tasty snack), and you can’t access the inside of the vending machine or alter its functions.

---

### References

[Microservices Authentication and Authorization Solutions](https://medium.com/tech-tajawal/microservice-authentication-and-authorization-solutions-e0e5e74b248a)
