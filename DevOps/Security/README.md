## Auth

It outlines different approaches of authenticating applications and their features.

- [JWT](#jwt)
- [Session(Cookie)](#session)
- [SSO](#sso)
- [OAuth2](#oauth2)
- [SAML](#saml)
- [SAML vs OAuth](#saml-vs-oauth)
- [CORS](./cors.md)
- [DDos](#ddos)
- [SSL Cert](#ssl-cert)

- [References](#references)

### JWT

- comprised of 3 parts - **xxxx.yyyyy.zzzz** = **header**.**payload(claim)**.**signature**. Each bit is base64 encoded.

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
          header                                         payload/claim                                                       signature
```

- header is as follow. It shows the algorithm we use to generate the signature. It needs to be base64 encoded.

```js
{
  "typ": "JWT",
  "alg": "HS256"
}
```

- payload(claim) contains metadata as follow. It then base64 encoded.

```js
{
  "iss": "Mr He. JWT", // issuer
  "iat": 1441593502, // issued at
  "exp": 1441594722, // expire at
  "aud": "www.lendi.com.au", // audience - server
  "sub": "david.he@lendi.com" // subject - client
}
```

- signature is generated by joining the above two base64 encoded strings first and then encrypted with secret - 'I love this game'.

```js
signature = header_alg(xxxxxxx.yyyyyyyy, YOUR_SECRET);
```

#### Important

- Never ever put the senstive data in **header** and **payload** - they are `base64` encoded not encrypted!!!
- Why do we need signature? - It prevents somebody modifying the data.
- How does server do the authentication? - Server will use the specified algorithm in the header, secret stored on the server, **header** and **payload** to generate another signature. Then, server will do the comparison with the sent one if they don't match it indicates the token has been tampered with.
- With JWT, you should NEVER EVER store token in db on server side. Instead it needs to be stored safely on client side.
- It makes scaling easier since any server in a cluster can serve the request given no session is kept on the server side.
- People use JWT to protect their APIs.
![jwt-based-auth](./jwt-based-auth.png)

#### Downsides

- JWT can be a sizeable piece of data in the header!
- Not suitable for holding user sessions i.e shopping cart

#### FAQs

- #### How to invalidate a token?

A: Add a property to your user object in the server database, to reference the datetime the token was created at. To invalidate the token, just update its value, and if `iat` (holding the same value at the time of token creation) is older than updated value, you can reject the token.

- #### Where should I save it on the client side?

A: JWT needs to be stored inside an `httpOnly cookie` - a special kind of cookie that’s only sent in HTTP requests to the server, and it’s never accessible (both for reading or writing) from JavaScript running in the browser.

Never save it to `localStorage`. If any of the third-party scripts you include in your page gets compromised, it can access all your users’ tokens.

---

### Session

- Used to know user session state.
- stateful - both server and client needs to keep a copy.
- sessionId is created and stored on the server (db or cache). It's also being sent down the wire to client through cookie.
- session data itself can be saved into db table.
- After authenticated, all subsequent requests will have sessionId attached automatically by browser.

![session-based-auth](./session-based-auth.png)

#### typical auth process

1. User enters their login credentials.
2. Server verifies the credentials are correct and creates a session which is then stored in a database.
3. A cookie with the session ID is placed in the users browser.
4. On subsequent requests, the session ID is verified against the database and if valid the request processed.
5. Once a user logs out of the app, the session is destroyed both client-side and server-side.

#### Downsides

- Cookies normally work on a single domain or subdomains and they are normally disabled by browser if they work cross-domain (3rd party cookies)
- Given the fact it's stored in server's memory, scaling becomes a problem since a different server than the original one who generates the sessionId would fail to know incoming request state.

#### FAQs

- #### How to manage session in a distributed environment?

A: Couple of ways:

- Sticky session - Which ensures that all requests from a specific user will be sent to the same server who handled the first request corresponding to that user, thus ensuring that session data is always correct for a certain user. The problem is it will cause uneven load distribution across servers.

- Centralized session storage - Means that when a user accesses a microservice, user data can be obtained from shared session storage, ensuring that all microservices can read the same session data

Other approaches are discussed in the `Microservices Authentication and Authorization Solutions` below.

- #### Where should I store session data?

A: 2 possible ways:

- Memory session store is going to be reset on every app re-lauch. Also it's fastest. i.e Redis
- Database session store, is going to be safe with app re-lauch. And at some point you will have alot of session objects which you might want to clean up. And same session stored in database can be even accessed from different apps.

---

### SSO

![](./sso_auth0.png)

Read more about [what is SSO and how it works](https://auth0.com/blog/what-is-and-how-does-single-sign-on-work/)

---

### OAuth2

- Four participants
  - Resource Owner - User
  - Resource Server - Google i.e Google Calendar
  - Authorization Server - Authenticate user credentials and gain user **access_token**
  - Client - 3rd party app i.e lendi
- **Resource Server** and **Authorization Server** can be the same server
- Full workflow
  1. **Client** sends request to **Resource Owner** for authorization. The OAuth **Client** includes its identifier, requested scope, local state, and a redirection URI.
  2. **Resource Owner** grants the access and sends the authorization code back to **Client**
  3. **Client** passes the authorization code to **Authorization Server**
  4. **Authorization Server** authenticates the code and sends **access_token** back to **Client**
  5. **Client** can then use **access_token** to get access to resources on the **Resource Server**
- In offline mode, **Authorization Server** also sends a **refresh_token** which is used later to exchange for another fresh **access_token** after previous one is expired without needing to go through all the steps again.

![](./oauth_2.png)

### SAML

Saml is a protocol for authentication. i.e Authenticating a client through IdP that's compatible with SAML so the client can access your application which it does not provide authentication but rather actual services/functionalities.

One use case scenario: Github redirects you to Google for authentication and once done bring you back to Github to provide resources to you. Google supports SAML 2.0 authentication strategy. See [SSO with SAML](https://docs.github.com/en/github/authenticating-to-github/authenticating-with-saml-single-sign-on)

![saml](saml.png)

### SAML vs OAuth

They are two different security protocols often used to implement SSO. In other words, SSO is kinda feature while SAML/OAuth are 2 different implementation strategies. The major difference is OAuth is primarily used for authorization whilst SAML is for authentication.

References

- [OAuth-vs-SAML](https://www.cloudflare.com/learning/access-management/what-is-oauth/)
- [SAML-vs-OAuth-vs-OPENID](https://juejin.im/post/6844903634094784520)
- [Use JumpCloud as IDP to authenticate users to access AWS](https://www.youtube.com/watch?v=JlX4pyQBecM)
- [Identity Providers and Federation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers.html)

### DDos

A distributed denial-of-service (DDoS) attack requires an attacker to gain control of a network of online machines in order to carry out an attack. Computers and other machines (such as IoT devices) are infected with malware, turning each one into a bot (or zombie). The attacker then has remote control over the group of bots, which is called a botnet.

Once a botnet has been established, the attacker is able to direct the machines by sending updated instructions to each bot via a method of remote control. When the IP address of a victim is targeted by the botnet, each bot will respond by sending requests to the target, potentially causing the targeted server or network to overflow capacity, resulting in a denial-of-service to normal traffic. Because each bot is a legitimate Internet device, separating the attack traffic from normal traffic can be difficult.

### SSL Cert

`subject` shows CN (common name) that is the DNS you wish to secure. This value needs to match request hostname i.e domain in your browser's address bar. If not, you will get `Common Name Mismatch` error.

The above check is aka Hostname Verification that involves a server identity check to ensure that the client is talking to the correct server and has not been redirected by a man in the middle attack.

The check involves looking at the certificate sent by the server, and verifying that the `dnsName` in the `subjectAltName` field of the certificate matches the host portion of the URL used to make the request.

```
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
subject=/CN=fluentbit.ap-southeast-2.dev.parrodise.dev
issuer=/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
```

Use `openssl` to establish a TLS connection to the remote. This command will return more connection details which really helps with connection issues troubleshooting.

```shell
$ openssl s_client -connect some-domain.com.au:24223
```

References

- [Understand ssl cert](https://www.cnblogs.com/iiiiher/p/8085698.html)

---

### References

[Microservices Authentication and Authorization Solutions](https://medium.com/tech-tajawal/microservice-authentication-and-authorization-solutions-e0e5e74b248a)
