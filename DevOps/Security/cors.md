## CORS

- [Same Origin and CORS](#same-origin-and-cors)
- [CSRF](#csrf)
- [JSONP](#jsonp)
- [How to enable cors?](#how-to-enable-cors)
- [SameSite](#same-site)
- [Preflight](#preflight)

### Same Origin and CORS

Same origin requires 2 urls to have same `protocol/domain/port`. If any of them is different, they are considered 2 different domains.

> SOP DOES NOT prevent sending requests. It does prevent a page from accessing results of cross-domain requests.

CORS stands for cross-origin resource sharing which is a way to circumvent same origin policy i.e ajax calls can only access resources on your domain not some other domains.

Note, client's request still hits the server and gets the response, but HTTP client like `fetch` which follows `same origin policy` will prevent the client accessing the response since there is a lack of `Access-Control-Allow-Origin` header. You can set up a proxy server to fix the problem if you don't have control over the server.

[Useful link](https://stackoverflow.com/questions/43871637/no-access-control-allow-origin-header-is-present-on-the-requested-resource-whe/43881141#43881141)

### CSRF

- User A signs into banking.com
- Authentication is passed. Server sets **cookie** on response header to retain A's login
- Say the api for money transfer is:
```
POST https://banking.com/onlinebanking/transfer?amount=500&accountNumber=213367 HTTP/1.1
```
Attacker forges a new url to transfer money to himself:
```
POST https://banking.com/onlinebanking/transfer?amount=500&accountNumber=888888 HTTP/1.1
```
- Attacker then tricks A into clicking the forged link by enclosing it in a phishing email to A.
- A clicks the link without signing out which ends up sending money to attacker. This happens is because session cookies are sent to the same origin automatically by browsers.

SOP will not stop CSRF at all!!! as it allows attacker to send requests but not accessing the response. A CSRF attack is done by sending a request, and not by reading anything from the response. In fact, you neither can nor need to read the response.

Solution is CSRF token. It's huge, randomly generated by the web page and is included in the submitted url as an unique-per-request value. As such, attacker will have no way of guessing the token right.

```
http://www.mybank.com/transfer?to=123456;amount=10000;token=31415926535897932384626433832795028841971
```

### jsonp

Altough ajax requests are restricted, remote scripts loaded via `src tags` are free to go.

```js
<script>
  function logMessage(json) {
    console.log(json.message);
  }
</script>
<script src="http://example.com/jsonpMessage?cb=logMessage"></script>
```

Downside of jsonp is - it only works for http `GET`.

### How to enable cors

**Origin** header specifies where this request is being sent from.

```js
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

Server responding without **Access-Control-Allow-Origin** will in turn trigger `onerror` in the ajax call.

Turn on cors for whole list of webistes as exceptions to same-origin policy. This time, server will respond

```js
// indicates whether the response can be shared with requesting code from the given origin.
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

Now, ajax calls to another domain is allowed.

### same-site

If a cookie's domain matches address currently shown in address bar, it's considered as a 1st party cookie otherwise it's a 3rd party cookie.

3rd party cookie use case - suppose site A has embedded a Youtube video on its site, a visitor who's signed in to Youtube will see `Watch Later` option rather than being prompted for login. It's happened so because visitor login state cookie - 3rd party cookie is sent by browser when loading Youtube video such that Youtube knows this visitor has already authenticated.

With SameSite, it allows users to control who the browser should send cookies to. i.e cross-site or same site.

```js
// same site
www.web.dev and static.web.dev

// cross site
your-project.github.io and my-project.github.io
```

With SameSite cookie attribute, we can effectively avoid CSRF attacks.

[Read More](https://web.dev/samesite-cookies-explained/)

### preflight

[preflight requests](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request)

To avoid sending too many `OPTIONS`, One could use a proxy server where frontend sends requests to its server - serving frontend code which then forwards the requests to actual API server - backend. Because the communication is between two servers, preflight calls are completed avoided.
